# VZLOGGING 日志库要求

现在我们平台内部，调试的方法非常有限，如果用户的设备出现了问题，那么我们就很难能够在现场将问题定位出现。有一些问题，是非常难以出现的，如果我们没有一个好的办法能够在定位当前设备状态下的问题的话，实践证明，我们也很难将这个问题解决。

提高调试手段是我们整个平台中亟待解决的问题。因此我们根据前面所实践设计我们自己的日志库。这个日志库有以下的一些特点。

1. 速度非常快，整个日志库使用异步的方式显示、保存日志，不阻塞当前线程，速度非常快。
2. 自动保存文件，这个日志库需要配合一个日志服务器一起使用，日志服务器负责将日志收集并且按一定的规划保存到文件中，能够达到限制日志大小，动态显示、过滤日志的功能。
3. 日志服务器同时是一个`WatchDog`服务端，能够检测所有的模块是否运行正常。如果运行不正常将会将当前的日志保存，并且重启设备，这样针对异常的设备重启，我们都能够看到更加详细的日志记录。

## 日志使用

日志库为了方便，提供了`C`和`C++`两种语言的接口，方便用户使用，更方便用户能够快速的将自己当前的日志切换到`vzlogging`中

### `C`语言接口

C语言的库头文件应该包含`"vzlogging/include/vzlogging.h"`,有几个接口

```c

#include "vzlogging/include/vzlogging.h"

int main(int argc, char *argv[]) {

  vzlogging::InitVzLogging(argc, argv);

  LOG_INFO("message %d", 8);
  LOG_WARNING("message %d", 8);
  LOG_ERROR("message %d", 8);

  DLOG_INFO("message %d", 8);
  DLOG_WARNING("message %d", 8);
  DLOG_ERROR("message %d", 8);

  return 0;
}
```

首先调用`InitVzLogging(argc, argv)`来初始化日志接口(主要接收"-v"参数实现本地屏幕输出打印)。初始化之后，就可以调用vzlogging相关的接口进行传输显示了。

- 以`LOG_*`开头的打印，会记录到日志文件中。
- 以`DLOG_*`开头的打印，只会显示不会记录到日志文件中。

### `C++`接口

`C++`的接口，应该包含头文件`"vzlogging/include/vzlogging.h"`

```c++
#include "vzlogging/include/vzlogging.h"

int main(int argc, char *argv[]) {

  vzlogging::InitVzLogging(argc, argv);

  LOG(L_INFO) << "Hello World!";
  LOG(L_WARNING) << "Hello World!";
  LOG(L_ERROR) << "Hello World!";

  DLOG(L_INFO) << "Hello World!";
  DLOG(L_WARNING) << "Hello World!";
  DLOG(L_ERROR) << "Hello World!";

  return 0;
}
```

首先调用`InitVzLogging(argc, argv)`来初始化日志接口(主要接收"-v"参数实现本地屏幕输出打印)。初始化之后，就可以调用vzlogging相关的接口进行传输显示了。

- 以`LOG(*)`开始的接口打印会保存到日志文件中。
- 以`DLOG(*)`开始的接口只会打印，不会保存到日志文件中。

---

1. 使用C++实现，但不能够使用STL，不能够引用任何的第三方库，只能够使用最原始的操作系统接口。
2. 跨平台支持，需要在Windows和Linux平台上面使用。
3. 不能够使用C++ 11特性，必须能够在GCC 4.3.3版本上面支持编译。
4. 支持多线程安全，多线程下打印日志不能够乱，打印日志不能够在当前线程输出。
5. 不能够动态的分配内存，所有的内存都只能够在启动的时候分配好，未来在运行过程中不再动态的分配内存。


### 日志模块的架构

日志服务一共分为两个主要的模块，一个日志服务器，一个日志库。日志库本身不会存放日志文件，它会将需要打印的内容通过UDP发送给日志服务器，由日志服务器来统一进行打印和保存日志。这样有几个特点

1. 平时运行过程中，可以不需要有任何打印(`printf`函数都不会调用)，包括日志服务器也不需要有任何打印。
2. 我们在运行过程中，可以重新启动日志服务器，这个时候可以看到整个系统中所有的模块的打印信息。而不需要像传统的调试方法那样，只能够将进程重启，才能够将打印重定向出来。
3. 日志服务器可以统一管理所有的日志文件，控制日志大小和相关的日志保存策略。

日志库和日志服务器之间有一个共享内存可以访问，这个共享内存由日志服务器创建，同时具有写入和读取的权限。日志库只能够读取里面的数据。这个共享内存主要有以下几个内容

1. 输出发送日志的级别。
2. 输出发送日志的服务端地址和端口

在正常的运行过程中，每一条打印，日志库都需要读取共享内存里面的东西，以决定输出的日志级别，并且将日志发送到相应的服务端地址和端口中去。

日志有三个级别，INFO、WARNING、ERROR。在正常的运行过程中，日志库不会在当前的线程输出任何东西(`printf`函数都不会调用)。只会在以`-v`运行的时候，才会在当前进程打印日志。这个时候打印就直接在当前线程打印就可以了，因为是调试的时候，不会太在意里面的效率。

日志服务端，主要做以下几件事情

1. 操作共享内存，以便控制其它日志库的输出。
2. 统一保存日志文件到log分区中。
3. 作为watchdog模块，决定哪个模块是否响应异常。如果出现异常模块，就保存日志文件，然后重启设备。
